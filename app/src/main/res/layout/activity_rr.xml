<?xml version="1.0" encoding="utf-8"?>

<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/scrollvw"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scrollbars="vertical"
    android:background="#a1dbcd">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Round Robin Scheduling"
        android:textColor="#FF0000"
        android:textSize="20dp"/>

    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="\n\nOne of the oldest, simplest, fairest and most widely used algorithm is round robin (RR).

\n\nIn the round robin scheduling, processes are dispatched in a FIFO manner but are given a limited amount of CPU time called a time-slice or a quantum.

\n\nIf a process does not complete before its CPU-time expires, the CPU is preempted and given to the next process waiting in a queue. The preempted process is then placed at the back of the ready list.

\n\nRound Robin Scheduling is preemptive (at the end of time-slice) therefore it is effective in time-sharing environments in which the system needs to guarantee reasonable response times for interactive users.

\n\nThe only interesting issue with round robin scheme is the length of the quantum. Setting the quantum too short causes too many context switches and lower the CPU efficiency. On the other hand, setting the quantum too long may cause poor response time and appoximates FCFS.

\n\nIn any event, the average waiting time under round robin scheduling is often quite long.\n\n"
        android:textColor="#000000"/>

    </LinearLayout>

</ScrollView>


